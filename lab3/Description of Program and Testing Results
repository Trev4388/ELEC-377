Partner 1: Trevor Kirton - 20160010- 18tk30
Partner 2: Travis Stephney - 20172675 - 18tms9

Description of Program:

The purpose of this lab is to be able to demonstrate the purpose of locks and shared memory. The purpose of using a lock for this lab is to ensure that the shared memory does not get accessed at the same time by multiple programs, as that can cause errors. The working programs in this lab include meminit, common, producer and consumer.
	Meminit is unchanged and its purpose is to clear the memory buffer at a certain location to ensure that each time the other programs run they use an empty memory space. Common is only changed in the get and release Mutex functions. These are made to set and release the lock which is commonly accessed by the producer and consumer. The common.c program is designed to be shared by the producer and consumer so that either programs must access the same lock, locking the memory until the program is finished, to ensure no errors occur when running programs concurrently.
	The producer.c program contains the code necessary to read characters and write them to the shared buffer. This is accomplished by using getMutex() and releaseMutex() to lock and unlock upon entering or exiting critical sections of the code or accessing the shared memory to ensure synchronization. The producer program increments the ‘prodCount’ variable to keep track of the number of producers and reads a file until the end is reached. As each character is read, so long as there is space in the buffer, it is written to the shared queue for the consumer to use. 
	The consumer.c program uses the same ideas as the producer.c to access the memory and instead of setting the memory it retrieves something from the memory. It first uses the getMutex() to get the lock, then gets the producer count and releases the lock via releaseMutex(). It continues to execute while there are producers remaining and while the flag is true. It accomplishes this through the use of a nested while loop within the main while loop. Must lock before and unlock after. While the count is greater than zero, get the character from the queue and store it in variable 'c'. Then update out_output, decrement count variable, and set flag. After releasing the lock, use putchar with 'c' variable as input.

Testing Results:

In order to test the program, two text files were made for input data and one for output. First the meminit function is called to clear the buffer. Then, the producer was called in two different consoles with the two input text files. The consumer was then called in a third console window with the output file. The two producers would add the data in their respective files to the queue 5 bytes at a time in the order in which they were called. The consumer then reads this data from the shared queue and writes it to its respective output text file. 
The first text file named ‘test00in.txt’ contains the phrase “Hello, World!” while the second text file named ‘test01in.txt’ contains the sentence “I can’t believe this actually worked”. The producers were called with these two files in this order resulting in the third file named ‘test02out.txt’ being used by the consumer. Upon completion, the consumer text file contains two lines, each of which corresponds to the lines in the two input files. Line 1 reads “Hello, World!” and line 2 reads “I can’t believe this actually worked”. 

